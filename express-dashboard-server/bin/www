#!/usr/bin/env node

/**
 * Module dependencies.
 */

global.timescale = 100*60.0;

global.bike_current_index = 1154185;

global.server_start_time = new Date();

const bike_start_time = new Date('2018-09-13 07:40:03');

global.bike_current_time = new Date(bike_start_time);

global.compressor_start_time = new Date('2019-04-15 08:00:00');

global.compressor_current_time = new Date(global.compressor_start_time);

var app = require('../app');
var debug = require('debug')('dashboard:www');
var http = require('http');

/**
 * Get port from environment and store in Express.
 */

var port = normalizePort(process.env.PORT || '3000');
app.set('port', port);

/**
 * Create HTTP server.
 */

var server = http.createServer(app);

/**
 * Listen on provided port, on all network interfaces.
 */

server.listen(port);
server.on('error', onError);
server.on('listening', onListening);

/**
 * Normalize a port into a number, string, or false.
 */

function normalizePort(val) {
	var port = parseInt(val, 10);

	if (isNaN(port)) {
		// named pipe
		return val;
	}

	if (port >= 0) {
		// port number
		return port;
	}

	return false;
}

/**
 * Event listener for HTTP server "error" event.
 */

function onError(error) {
	if (error.syscall !== 'listen') {
		throw error;
	}

	var bind = typeof port === 'string'
		? 'Pipe ' + port
		: 'Port ' + port;

	// handle specific listen errors with friendly messages
	switch (error.code) {
		case 'EACCES':
			console.error(bind + ' requires elevated privileges');
			process.exit(1);
			break;
		case 'EADDRINUSE':
			console.error(bind + ' is already in use');
			process.exit(1);
			break;
		default:
			throw error;
	}
}

/**
 * Event listener for HTTP server "listening" event.
 */

function onListening() {
	var addr = server.address();
	var bind = typeof addr === 'string'
		? 'pipe ' + addr
		: 'port ' + addr.port;
	debug('Listening on ' + bind);
}

/**
 * Real-time data with socket.io
 */

var compressor_last_sent = new Date(global.compressor_start_time);

const io = require('socket.io')(server);
const datasets = require('../data/datasets').datasets;
const compressors = require('../data/datasets').compressors;
const C = require('../data/constants.js').COMPRESSORS;

const emitBikeData = async socket => {
	var data = datasets['bike'];

	global.bike_current_time = new Date(bike_start_time.valueOf() + global.timescale*(new Date() - global.server_start_time));

	var new_data = [];
	for( ; global.bike_current_index < data.length; global.bike_current_index++)
	{
		var date = new Date(data[global.bike_current_index].start_time);

		if(date <= global.bike_current_time) {
			new_data.push(data[global.bike_current_index]);
		}
		else {
			break;
		}
	}

	if(new_data.length)
	{
		socket.emit("bike_data", new_data);
	}
};

const emitCompressorData = async (socket, id) => {
	var c = compressors[id];

	const formatDate = require('../data/utility.js').formatDate;

	var start = new Date(compressor_last_sent);
	global.compressor_current_time = new Date(global.compressor_start_time.valueOf() + global.timescale*(new Date() - global.server_start_time));
	compressor_last_sent = new Date(global.compressor_current_time);

	var new_data = [];
	for(var i = 4300 + c.index_offset; i < (datasets['compressor'].length - c.index_offset); i++) {
		
		var start_time = new Date(new Date(datasets['compressor'][i].start_time).valueOf() + c.start_time_offset)

		if(start_time > start)
		{
			if(start_time > global.compressor_current_time)
			{
				break;
			}

			var data_entry = {};

			data_entry.start_time = formatDate(start_time);

			var v = datasets['compressor'][i];

			data_entry.flow = +v.flow + c.flow_offset;
			data_entry.bearing_vibration = +v.bearing_vibration + c.bearing_vibration_offset;
			data_entry.oil_pressure = +v.oil_pressure + c.oil_pressure_offset;
			data_entry.oil_temp = +v.oil_temp + c.oil_temp_offset;
			data_entry.ambient_temp = +v.ambient_temp + c.ambient_temp_offset;
			data_entry.humidity = v.humidity + c.humidity_offset;

			var v_add = c.vibration_add.get(data_entry.start_time);
			var p_add = c.pressure_add.get(data_entry.start_time);
			data_entry.bearing_vibration += v_add ? v_add : 0;
			data_entry.oil_pressure += p_add ? p_add : 0;

			if(c.status == 2)
			{
				data_entry.flow = 0;
				data_entry.bearing_vibration = 0;
				data_entry.oil_pressure = 0;
			}

			new_data.push(data_entry);
		}
	}

	if(new_data.length)
	{
		socket.emit("compressor_data", new_data);
	}
};

let bike_interval;
let compressor_interval;
io.on("connection", socket => {
	console.log("New client connected");

	socket.on('dataset', dataset => {
		switch(dataset.name)
		{
			case 'bike':
				if(bike_interval) {
					clearInterval(bike_interval);
				}
				bike_interval = setInterval(() => emitBikeData(io.sockets), 1000);
				break;

			case 'compressor':
				if(compressor_interval) {
					clearInterval(compressor_interval);
				}
				//TODO: Will only send data for the ID corresponding to the first connected client request.
				compressor_interval = setInterval(() => emitCompressorData(io.sockets, dataset.id), 1000);
				break;

			default:
				break;
		}
	});

	socket.on("disconnect", () => { console.log("Client disconnected")});
});
